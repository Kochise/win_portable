//import moda
//import modb as mb

import localmod

const (
	pi = 3
	pi2 = pi
	//s = 'hi'

)

struct User {
	age  int
	name string
}

enum Color {
	red green blue
}

fn main() {
	a := 10
	//bb := 2 + 'hi'
	a++
	negative := -a
	2 < 3
	a == 1
	a++
	foo(3)
	ak := 10
	mypi := pi
	color := Color.red
	localmod.pub_foo()
	ten := localmod.get_int_10()
	println(localmod.pub_int_const)
	g := int(3.0)
	bytes := &byte(0)
	user_ptr := &User{}
}
	/*
	user := User{}
	user.age = 10
	mut x := if user.age == 10 { 20 } else { user.age * 2 }
	for x > 3 {

	}
	*/

struct One {
	two Two
}

struct Two {

}

fn foo(a int) {
	for true {

	}
	for i := 0; i < 10; i++ {

	}
	mut nums := [1,2,3]
	nums2 := nums[..2]
	nums3 := nums[1..2]
	nums4 := nums[1..]
	number := nums[0]
	nums[1] = 10
	bools := [true, false]
	users := [User{}]
	//ptr := &User{}
	b := bools[0]
	mystrings := ['a', 'b']
	s := mystrings[0]
	//////////
	mut x := 0
	x=get_int2()
	n := get_int2()
	q := true || false
	b2 := bools[0] || true
	b3 := get_bool() || true
	f := nums.first()
	c := nums.clone()
	d := 'd'
	println(s + d)
	//cloned = nums.clone()
	//cloned1 := cloned[0]
	//println(cloned1 == 1)
	/*
	mut strings := ['hi', 'hello']
	strings << 'a' + b
	*/

}

fn C.printf()

fn (u mut User) inc_age(n int) {
	C.printf("%d", u.age)
	u.age += n
}

fn get_int(a string) int {
	return 10
}

fn get_bool() bool {
	return true
}

fn get_int2() int {
	a := 'hello'
	//return get_int('sdf')
	return get_int(a)
}

fn myuser() {
	x := 1
	q := x | 0x1004
	user := User{age:30}
	age := user.age + 1 // crash here
	boo := 2
	boo2 := boo+1
	b := age > 0
	b2 := user.age > 0
	mut user2 := User{age:20}
	user2.age = 20 + boo
}

fn multi_return() (int,string) {
	return 4, 'four'
}

fn variadic(a ...int) {
	x := path_sep
	y := if true { 1 } else { 0 } // TODO cgen
}

fn ensure_cap(required int, cap int) {
	if required < cap {
		return
	}
}

fn println(s string){}

fn matches() {
	a := 100
	match a {
		10 {
			println('10')
		}
		20 {
			k := a + 1
		}
		else{}
	}
	x := match a {
		10 { 'ten' }
		30 { 'thirty' }
		else { 'unknown' }
	}
	xx := match a {
		10 { 100 }
		30 { 300 }
		else { 0 }
	}
	println(match a {  10 { 'ten' } else { 'not ten' } })
	/*
	n := match a {
		1 { 10 }
		2 { 20 }
		else { 30 }
	}
	*/
}

const (
	path_sep = 10
)

fn end() {
	i := 2
	key := 10
	x := i != -1 && key == 10 // key == keys[i]
	e := 2 + 3 * 4
	//mut a := [1,2,3]
	//(a << 4) + 2
}

///////////////////////////////////////////////////////////

fn function1() int {
	a := 10 + 1
	b := a + 1
	//return a
	return 0
}

fn foo(a int) {
	//end()
}

struct User {
	name string
}

fn init_user() {
	user := User{
		name: 'Bob'
	}
}

fn get_user() User {
	user := User{}
	return user
}


fn puts(s string) {}

// comment
fn function2() {
	mut x := 0
	//mut negative := -1
	f := 10.1
	s := 'hi'
	mut m := 10
	x += 10
	x += 1
	m += 2
	function1()
	// a += 1
	// c := 0
	if true {
		foo(10)
		x += 8
	}
	if false {
		foo(1)
	}
	else {
		puts('else')
		foo(100)
	}
	for true {
		init_user()
	}
	e := 1 + 2 > 0
	e2 := 1 + 2 < 0
	// x += 1
	j := 0
}

fn init_array() {
	nums := [4,2,3]

}


/*
fn bool_array() {
       a := [true, false]
       b := a[0]
       if b {
               println('ok')
       }
}
*/



