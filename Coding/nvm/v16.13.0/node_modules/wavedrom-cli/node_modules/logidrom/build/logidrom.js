(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.logidrom = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

exports['B612'] = function() {
  const table = [
      '24',
      '30',
      '36',
      '40',
      '42',
      '48',
      '54',
      '60',
      '63',
      '66',
      '72',
      '78',
      '84',
      '90',
      '96',
      '102',
      '108',
      '114',
      '120',
      '77.890625'
    ],
    baseSize = 120,
    height = 147.34375,
    descent = 51.5703125,
    defaultWidth = 96,
    re = new RegExp('([\'\\|])|([,;])|([\\.:Ii])|([j])|([!l])|(["frt])|([\\(\\)\\-J\\[s])|([=\\]cz])|([a])|([\\$\\*/\\?FLS\\\\_`ekvxy])|([\\+CEKPTYZbdghnopqu\\}])|([0123456789<>ABDGRVX])|([&HU])|([N\\^w~])|([OQ])|([#])|([%Mm])|([W])|([@])|([\\{])');
  return function(fontSize) {
    const ratio = fontSize / baseSize;
    const getIndex = ch => {
      const m = ch.match(re);
      if (m !== null)
        for (let i = 0; i < table.length; i += 1)
          if (m[i + 1] !== undefined)
            return i;
    };
    const getWidth = str => {
      return str.split('').reduce((acc, e) => acc + (table[getIndex(e)] || defaultWidth) * ratio, 0);
    };
    return {
      getHeight: function() {
        return ratio * height;
      },
      getDescent: function() {
        return ratio * descent;
      },
      getWidth: getWidth
    };
  };
};

},{}],2:[function(require,module,exports){
'use strict';

const tspan = require('tspan');

const circle = 'M 4,0 C 4,1.1 3.1,2 2,2 0.9,2 0,1.1 0,0 c 0,-1.1 0.9,-2 2,-2 1.1,0 2,0.9 2,2 z';
const buf1 = 'M -11,-6 -11,6 0,0 z m -5,6 5,0';
const and2 = 'm -16,-10 5,0 c 6,0 11,4 11,10 0,6 -5,10 -11,10 l -5,0 z';
const or2 = 'm -18,-10 4,0 c 6,0 12,5 14,10 -2,5 -8,10 -14,10 l -4,0 c 2.5,-5 2.5,-15 0,-20 z';
const xor2 = 'm -21,-10 c 1,3 2,6 2,10 m 0,0 c 0,4 -1,7 -2,10 m 3,-20 4,0 c 6,0 12,5 14,10 -2,5 -8,10 -14,10 l -4,0 c 1,-3 2,-6 2,-10 0,-4 -1,-7 -2,-10 z';
const circle2 = 'c 0,4.418278 -3.581722,8 -8,8 -4.418278,0 -8,-3.581722 -8,-8 0,-4.418278 3.581722,-8 8,-8 4.418278,0 8,3.581722 8,8 z';

const gates = {
  '=': buf1, '~':  buf1 + circle,
  '&': and2, '~&': and2 + circle,
  '|': or2,  '~|': or2  + circle,
  '^': xor2, '~^': xor2 + circle,
  '+': 'm -8,5 0,-10 m -5,5 10,0 m 3,0' + circle2,
  '*': 'm -4,4 -8,-8 m 0,8 8,-8  m 4,4' + circle2,
  '-': 'm -3,0 -10,0 m 13,0' + circle2
};


const aliasGates = {
  add: '+', mul: '*', sub: '-',
  and: '&', or: '|', xor: '^',
  andr: '&', orr: '|', xorr: '^',
  input: '='
};

Object.keys(aliasGates).reduce((res, key) => {
  res[key] = gates[aliasGates[key]];
  return res;
}, gates);

const gater1 = {
  is:     type => (gates[type] !== undefined),
  render: type => ['path', {class:'gate', d: gates[type]}]
};

const iec = {
  eq: '==', ne: '!=',
  slt: '<', sle: '<=',
  sgt: '>', sge: '>=',
  ult: '<', ule: '<=',
  ugt: '>', uge: '>=',
  BUF: 1, INV: 1, AND: '&', NAND: '&',
  OR: '\u22651', NOR: '\u22651', XOR: '=1', XNOR: '=1',
  box: '', MUX: 'M'
};

const circled = {INV: 1, NAND: 1, NOR: 1, XNOR: 1};

const gater2 = {
  is:      type => (iec[type] !== undefined),
  render: (type, ymin, ymax) => {
    if (ymin === ymax) {
      ymin = -4; ymax = 4;
    }
    return ['g',
      ['path', {
        class: 'gate',
        d: 'm -16,' + (ymin - 3) + ' 16,0 0,' + (ymax - ymin + 6) + ' -16,0 z' + (circled[type] ? circle : '')
      }],
      ['text', {x:-14, y:4, class: 'wirename'}].concat(tspan.parse(iec[type]))
    ];
  }
};

function drawBody (type, ymin, ymax) {
  if (gater1.is(type)) { return gater1.render(type); }
  if (gater2.is(type)) { return gater2.render(type, ymin, ymax); }
  return ['text', {x:-14, y:4, class: 'wirename'}].concat(tspan.parse(type));
}

module.exports = drawBody;

},{"tspan":15}],3:[function(require,module,exports){
'use strict';

const tspan = require('tspan');

const drawGate = require('./draw_gate.js');

function drawBoxes (tree, xmax) {
  const ret = ['g'];
  const spec = [];
  if (Array.isArray(tree)) {
    spec.push(tree[0].name);
    spec.push([32 * (xmax - tree[0].x), 8 * tree[0].y]);

    for (let i = 1; i < tree.length; i++) {
      const branch = tree[i];
      if (Array.isArray(branch)) {
        spec.push([32 * (xmax - branch[0].x), 8 * branch[0].y]);
      } else {
        spec.push([32 * (xmax - branch.x), 8 * branch.y]);
      }
    }
    ret.push(drawGate(spec));
    for (let i = 1; i < tree.length; i++) {
      const branch = tree[i];
      ret.push(drawBoxes(branch, xmax));
    }
    return ret;
  }

  const fname = tree.name;
  const fx = 32 * (xmax - tree.x);
  const fy = 8 * tree.y;
  ret.push(
    ['g', {transform: 'translate(' + fx + ',' + fy + ')'},
      ['title'].concat(tspan.parse(fname)),
      ['path', {d:'M 2,0 a 2,2 0 1 1 -4,0 2,2 0 1 1 4,0 z'}],
      ['text', {x:-4, y:4, class:'pinname'}]
        .concat(tspan.parse(fname))
    ]
  );
  return ret;
}

module.exports = drawBoxes;

},{"./draw_gate.js":4,"tspan":15}],4:[function(require,module,exports){
'use strict';

const tspan = require('tspan');
const drawBody = require('./draw_body.js');

// ['type', [x,y], [x,y] ... ]
function drawGate (spec) { // ['type', [x,y], [x,y] ... ]

  const ilen = spec.length;
  const ys = [];

  for (let i = 2; i < ilen; i++) {
    ys.push(spec[i][1]);
  }

  const ret = ['g'];

  const ymin = Math.min.apply(null, ys);
  const ymax = Math.max.apply(null, ys);

  ret.push(['g',
    {transform: 'translate(16,0)'},
    ['path', {
      d: 'M' + spec[2][0] + ',' + ymin + ' ' + spec[2][0] + ',' + ymax,
      class: 'wire'
    }]
  ]);

  for (let i = 2; i < ilen; i++) {
    ret.push(['g',
      ['path', {
        d: 'm' + spec[i][0] + ',' + spec[i][1] + ' 16,0',
        class: 'wire'
      }]
    ]);
  }

  ret.push(['g',
    {transform: 'translate(' + spec[1][0] + ',' + spec[1][1] + ')'},
    ['title'].concat(tspan.parse(spec[0])),
    drawBody(spec[0], ymin - spec[1][1], ymax - spec[1][1])
  ]);

  return ret;
}

module.exports = drawGate;

},{"./draw_body.js":2,"tspan":15}],5:[function(require,module,exports){
'use strict';

const tt = require('onml/tt.js');
const {B612} = require('./B612.js');

const f = B612()(16);

const grid = 32;

const ceil = (n, step) => step * Math.ceil(n / step);

const widther = w => (w === 0) ? 'zeroer' : (w === 1) ? 'scalar' : 'vector';

const signed = node => (node.signed ? '' : 'un') + 'signed';

const siglabel = node => (node.signed ? '' : 'un') + 'siglabel';

const symbols = {
  andr: '&', orr: '≥1', xorr: '=1',
  neg: 'neg', not: 'not',

  add:  '+', sub:  '-',
  mul:  '*', div:  '/',      rem:  '%',
  lt: '<', leq: '≤', gt: '>', geq: '≥', eq: '=', neq: '≠',
  dshl: '<<', dshr: '>>',
  and:  '&', or:  '≥1', xor:  '=1',
  cat: '}',
  validif: 'vif'
};

const renderLiteral = (node, ch) => {
  const label = node.value.toString();
  const w = ceil(f.getWidth(label) + 5, grid);
  const h = Math.max(ch, grid);
  const res = ['g', {w, h, id: 'literal'},
    ['title', {}, node.width],
    ['rect', {class: 'literal', width: w - 4, height: h - 4, x: 2, y: -h / 2 + 2}],
    ['text', {
      class: siglabel(node),
      x: w / 2,
      y: 5
    }, label]
  ];
  return res;
};


const renderParameter = (node, ch) => {
  const label = node.name.toString();
  const w = ceil(f.getWidth(label) + 5, grid);
  const h = Math.max(ch, grid);
  const res = ['g', {w, h},
    ['rect', {class: 'literal', width: w - 4, height: h - 4, x: 2, y: -h / 2 + 2}],
    ['text', {class: 'parameter', x: w / 2, y: 5}, label]
  ];
  return res;
};



const renderWire = (node, ch, reuse) => {
  const label = node.name;
  const w = ceil(f.getWidth(label), grid);
  const k = (f.getHeight() / 2 + 1) |0;
  const h = Math.max(ch, 2 * k + 8);
  const res = ['g', {w, h}]
    .concat(
      reuse ? [] : [['path', {
        class: 'mark ' + signed(node),
        d: ['M', 0, -k, 'l', w, 0, 'l', 0, 2 * k, 'l', -w, 0, 'z']
      }]],
      [['text', {
        class: siglabel(node),
        x: w / 2,
        y: k - 4
      }, node.name]]
    );
  return res;
};

const regShapeD = (hbox, wbox, reset) => [
  'm', 0, hbox / 2 - 2,
  'v', 4 - hbox
].concat(
  reset ? [
    'h', wbox / 2 - 4,
    'a', 4, 4, 0, 0, 0, 8, 0,
    'h', wbox / 2 - 4
  ] : [
    'h', wbox
  ],
  [
    'v', hbox - 4,
    'h', 6 - wbox / 2,
    'l', -6, -8, -6, 8,
    'z'
  ]
);

const renderReg = (node, ch, reuse) => {
  const label = node.name;
  const w = ceil(f.getWidth(label), grid);
  const k = (f.getHeight() / 2 + 1) |0;
  const h = Math.max(ch, 2 * k + 8);
  const hbox = Math.min(h, 2 * grid);
  const res = ['g', {w: w + 2 * grid, h}];
  if (!reuse) {
    return res.concat([
      ['path', {
        class: ['dff', signed(node), widther(node.width)],
        d: regShapeD(hbox, grid, (node.type === 'regr'))
      }],
      ['path', {
        class: [signed(node), widther(node.width)],
        d: ['M', grid, 0, 'h', grid, 'm', 0, -k, 'h', w, 'v', 2 * k, 'h', -w, 'z']
      }],
      ['text', {
        class: ['dff', siglabel(node)],
        x: grid / 2,
        y: k - 4
      }, 'ff\u00A0'], // \uFB00
      ['text', {
        class: siglabel(node),
        x: w / 2 + 2 * grid,
        y: k - 4
      }, node.name]
    ]);
  }

  return res.concat([['text', {
    class: siglabel(node),
    x: 2 * grid + w / 2,
    y: k - 4
  }, node.name]]);
};

const renderOutput = (node, ch, reuse) => {
  const label = node.name;
  const w = ceil(f.getWidth(label), grid);
  const k = (f.getHeight() / 2 + 1) |0;
  const h = Math.max(ch, 2 * k + 8);
  const res = ['g', {w, h}]
    .concat(
      reuse ? [] : [['path', {
        class: ['mark', signed(node)],
        d: ['M', 0, -k, 'h', w - k, 'l', k, k, 'l', -k, k, 'h', -(w - k), 'z']
      }]],
      [['text', {
        class: siglabel(node),
        x: w / 2,
        y: k - 4
      }, node.name]]
    );
  return res;
};

const renderInput = (node, ch) => {
  const label = node.name;
  const w = ceil(f.getWidth(label) + 5, grid);
  const k = (f.getHeight() / 2 + 1) |0;
  const h = Math.max(ch, 2 * k + 8);
  const res = ['g', {w, h},
    ['title', {}, node.width],
    ['path', {
      class: ['mark', signed(node), widther(node.width)],
      d: ['M', 0, -h / 2 + 6, 'h', w - k, 'l', k, k, 'l', -k, k, 'h', -(w - k), 'z']
    }],
    ['text', {
      class: siglabel(node),
      x: w / 2,
      y: k - 4
    }, node.name]
  ];
  return res;
};

const buf1 = ['m', 0, -12, 'v', 24, 'l', 22, -12, 'z', 'm', 24, 12];
// const circle = 'c 0,1.8 2.2,4 4,4 c 1.8,0 4,-2.2 4,-4 c 0,-1.8 -2.2,-4 -4,-4 c -1.8,0 -4,2.2 -4,4 z';
const circle = ['a', 4, 4, 0, 1, 1, 0, .01];
// const circle = 'm 0,0 c 0,2.2 -2.2,0 4,4 c 2.2,0 0,2.2 4,-4 c 0,-2.2 0,-2.2 -4,-4 c -2.2,0 0,-2.2 -4,4 z';

const and1 = [
  'm', 0, -10,
  'h', 12,
  'a', 10, 10, 0, 1, 1, 0, 20,
  'h', -12,
  'z',
  'm', 22, 10,
  'h', 10
];

const or1 = [
  'm', -2, 10,
  'a', 22, 22, 0, 0, 0, 0, -20,
  'h', 10,
  'a', 20, 20, 0, 0, 1, 17, 10,
  'a', 20, 20, 0, 0, 1, -17, 10,
  'z',
  'm', 26, -10,
  'h', 8
];

const xor1 = [
  'm', -2, -10,
  'a', 22, 22, 0, 0, 1, 0, 20,
  'm', 4, 0,
  'a', 22, 22, 0, 0, 0, 0, -20,
  'h', 10,
  'a', 22, 22, 0, 0, 1, 16, 10,
  'a', 22, 22, 0, 0, 1, -16, 10,
  'z',
  'm', 25, -10,
  'h', 5
];

const and2 = [
  'm', 0, -20,
  'h', 12,
  'a', 20, 20, 0, 1, 1, 0, 40,
  'h', -12,
  'z'
];

const or2 = [
  'm', -2, 20,
  'a', 40, 40, 0, 0, 0, 0, -40,
  'a', 33, 33, 0, 0, 1, 34, 20,
  'a', 33, 33, 0, 0, 1, -34, 20,
  'z'
];

const xor2 = [
  'm', -2, -20,
  'a', 40, 40, 0, 0, 1, 0, 40,
  'm', 6, 0,
  'a', 40, 40, 0, 0, 0, 0, -40,
  'a', 30, 30, 0, 0, 1, 28, 20,
  'a', 30, 30, 0, 0, 1, -28, 20,
  'z'
];

const circle2 = ['a', 20, 20, 0, 1, 0, 0, .01];

const shapes = {
  not: buf1.concat(circle),
  and: and2,
  or: or2,
  xor: xor2,
  andr: and1,
  orr: or1,
  xorr: xor1,

  add: [
    'm', 12, 10,  'v', -20,
    'm', -10, 10, 'h', 20,
    'm', 10, 0
  ].concat(circle2),

  mul: [
    'm', 20, 8, 'l', -16, -16,
    'm', 0, 16, 'l', 16, -16,
    'm', 12, 8
  ].concat(circle2),

  div: [
    'm', 4, 8, 'l', 16, -16,
    'm', 12, 8
  ].concat(circle2),

  rem: [
    'm', 2, -6, 'a', 4, 4, 0, 1, 1, 0, .01,
    'm', 2, 14, 'l', 16, -16,
    'm', -6, 14, 'a', 4, 4, 0, 1, 1, 0, .01,
    'm', 18, -6
  ].concat(circle2),

  sub: [
    'm', 22, 0, 'h', -20,
    'm', 30, 0
  ].concat(circle2)
};

const renderShape = (node, ch) => {
  const w = grid;
  const h = Math.max(ch, grid);
  const res = ['g', {w, h, class: 'gate'},
    ['title', {}, node.width],
    ['path', {
      class: [signed(node), widther(node.width)],
      d: shapes[node.type]
    }]
  ];
  return res;
};

const renderBox = (node, ch) => {
  const w = grid;
  const h = Math.max(ch, grid);
  const hh = Math.max(node.arguments.length, 1) * grid;
  const res = ['g', {w, h, class: 'gate', id: node.path},
    ['title', {}, node.width],
    ['rect', {
      class: [signed(node), widther(node.width)],
      width: grid,
      height: hh - 8,
      x: 0,
      y: -hh / 2 + 4
    }],
    ['text', {x: grid / 2, y: 5}, symbols[node.type]]
  ];
  return res;
};

const slice = (hi, lo) => '[' +
  ((hi < lo) ? '' : (hi === lo) ? lo : (hi + ':' + lo)) + ']';

const renderSlice = (node, ch) => {
  const [inp, p1, p2] = node.arguments;
  let label = node.type;
  switch (node.type) {
  case 'head': label = slice(inp.width - 1, inp.width - p1.name); break;
  case 'tail': label = slice(inp.width - p1.name - 1, 0); break;
  case 'bits': label = slice(p1.name, p2.name); break;
  case 'shl':  label = '<< ' + p1.name; break;
  case 'shr':  label = '>> ' + p1.name; break;
  case 'pad': label = (p1.name <= inp.width) ? '=' : 'ext';
  }
  const w = ceil(f.getWidth(label) + 5, grid);
  const h = Math.max(ch, grid);
  const res = ['g', {w, h},
    ['title', {}, node.type],
    ['rect', {class: 'literal', width: w - 4, height: grid - 4, x: 2, y: 2 - grid / 2}],
    ['text', {class: 'parameter', x: w / 2, y: 5}, label]
  ];
  return res;
};

const renderMux = (node, ch) => {
  const w = grid;
  const h = Math.max(ch, grid);
  // const totals = node.arguments.map(e => e.hTotal);
  // const offset0 = Math.min(totals[0], ch / 2 - grid);
  // const from = Math.min(totals[0] + totals[1] / 2, h / 2) - grid / 2;
  const res = ['g', {w, h, class: 'gate'},
    ['title', {}, node.width],
    ['path', {
      class: [signed(node), widther(node.width)],
      d: ['M', 0, -grid / 4 * 3, 'l', grid, grid / 2, 'v', grid / 4 * 5, 'l', -grid, grid / 2, 'z']
    }],
    ['path', {
      class: 'unsigned',
      d: ['M', 0, -grid, 'h', grid / 2, 'v', grid / 2]
    }],
    ['text', {x: grid / 4, y: 5}, 0],
    ['text', {x: grid / 4, y: grid + 5}, 1]
  ];
  return res;
};

const renderOther = (node, ch) => {
  const w = 2 * grid;
  const h = Math.max(ch, grid);
  return ['g', {w, h},
    ['path', {class: 'mark', d: ['M', 0, 0, 'L', grid, h / 2, 'V', h]}],
    ['text', {class: 'label', x: grid / 2, y: h / 2 + 5}, node.type],
    ['title', ['tspan', node.type]]
  ];
};

const renderCvt = (node, ch) => {
  const w = 2 * grid;
  const h = Math.max(ch, 3);
  return ['g', {w, h},
    ['line', {
      class: [
        signed(node),
        widther(node.width)
      ],
      x1: 0, y1: 0, x2: grid, y2: 0
    }],
    ['line', {
      class: [
        signed(node),
        widther(node.width)
      ],
      x1: grid, y1: 0, x2: 2 * grid, y2: 0
    }]
  ];
};

const lut = {
  input: renderInput,
  output: renderOutput,
  wire: renderWire,
  reg: renderReg, regr: renderReg, rega: renderReg,
  Int: renderLiteral,
  asSInt: renderCvt, asUInt: renderCvt, cvt: renderCvt,
  tail: renderSlice, head: renderSlice, bits: renderSlice,
  shl: renderSlice, shr: renderSlice, pad: renderSlice,
  mux: renderMux,
  parameter: renderParameter,
  other: renderOther
};

const getBody = (node, ch, reuse) =>
  (
    (shapes[node.type] && renderShape) ||
    lut[node.type] ||
    (symbols[node.type] && renderBox) ||
    lut.other
  )(node, ch, reuse);

const wire = (arg, x, y1, y2) => {
  const klass = [
    signed(arg),
    widther(arg.width)
  ];
  if (y1 == y2) {
    return ['line', {
      class: klass,
      x1: x,         y1,
      x2: x + grid,  y2
    }];
  }
  return ['path', {
    class: klass,
    d: ['M', x, y1, 'h', grid / 2, 'v', y2 - y1, 'h', grid / 2]
  }];
};

const tree = node => {

  let hTotal = node.hTotal;
  let wTotal = node.wTotal;
  let g = ['g', {}];
  let reuse = false;

  const args = (node.arguments || [])
    .filter(arg => arg.type !== 'parameter');

  if (wTotal === undefined) {
    const children = args.map(tree);

    ({wTotal, hTotal} = children.reduce((res, e) => {
      res.wTotal = Math.max(res.wTotal, e[1].w);
      res.hTotal += e[1].h;
      return res;
    }, {wTotal: 0, hTotal: 0}));

    ({g} = children.reduce((res, e, ei) => {
      res.g.push(['g', tt(wTotal - e[1].w, res.y), e]);
      res.g.push(wire(
        args[ei],
        wTotal,
        res.y + e[1].h / 2,
        hTotal / 2 + (ei - children.length / 2 + 0.5) * grid
      ));
      res.y += e[1].h;
      return res;
    }, {y: 0, g}));
    node.wTotal = wTotal;
    hTotal = node.hTotal = Math.max(hTotal, grid);
  } else {
    reuse = true;
    hTotal = node.hTotal = grid;
  }

  const body = getBody(node, hTotal, reuse);
  g.push(['g', tt(wTotal + grid, hTotal / 2), body]);
  g[1].w = wTotal + grid + body[1].w;
  g[1].h = body[1].h;
  return g;
};

const excluder = node => {
  switch(node.type) {
  case 'input':
  case 'wire':
  case 'reg':
  case 'regr':
    return false;
  // case 'output':
  //   if (node.usage > 0) { return false; }
  }
  return true;
};

const forest = circuit => {
  const res = ['g', tt(.5, .5)];
  const modBackGround = ['rect', {x: -grid / 2, y: -grid, height: 1.5 * grid}];
  let w = 256;
  let h = grid / 2;
  circuit.map(mod => {
    res.push(['g', tt(grid, h + grid),
      modBackGround,
      ['text', {class: 'modName'}, mod.name]
    ]);
    h += 2 * grid;
    mod.body.filter(excluder).map(node => {
      const e = tree(node);
      res.push(['g', tt(0, h), e]);
      h += e[1].h;
      w = Math.max(w, e[1].w);
    });
    h += grid;
  });
  res[1].w = w + grid;
  res[1].h = h + grid;
  modBackGround[1].width = w;
  return res;
};

module.exports = forest;

},{"./B612.js":1,"onml/tt.js":14}],6:[function(require,module,exports){
'use strict';

const genSvg = require('onml/gen-svg.js');

const forest = require('./fir-forest.js');

const render = circuit => {
  const body = forest(circuit);
  const {w, h} = body[1];
  return genSvg(w, h).concat([body]);
};

module.exports = render;

},{"./fir-forest.js":5,"onml/gen-svg.js":13}],7:[function(require,module,exports){
'use strict';

const renderAssign = require('./render-assign.js');
const r = require('./r.js');
const fir = require('./fir-render.js');

exports.renderAssign = renderAssign;
exports.r = r;
exports.fir = fir;

},{"./fir-render.js":6,"./r.js":9,"./render-assign.js":10}],8:[function(require,module,exports){
'use strict';

function insertSVGTemplateAssign () {
  return ['style', '.pinname {font-size:12px; font-style:normal; font-variant:normal; font-weight:500; font-stretch:normal; text-align:center; text-anchor:end; font-family:Helvetica} .wirename {font-size:12px; font-style:normal; font-variant:normal; font-weight:500; font-stretch:normal; text-align:center; text-anchor:start; font-family:Helvetica} .wirename:hover {fill:blue} .gate {color:#000; fill:#ffc; fill-opacity: 1;stroke:#000; stroke-width:1; stroke-opacity:1} .gate:hover {fill:red !important; } .wire {fill:none; stroke:#000; stroke-width:1; stroke-opacity:1} .grid {fill:#fff; fill-opacity:1; stroke:none}'];
}

module.exports = insertSVGTemplateAssign;

},{}],9:[function(require,module,exports){
'use strict';

const estraverse = require('estraverse');
const renderAssign = require('./render-assign.js');

const Syntax = estraverse.Syntax;

function r (tree, options) {
  let res;
  estraverse.traverse(tree, {
    leave: function (node) {
      switch (node.type) {
      case Syntax.Identifier:
        node.aaa = node.name;
        break;
      case Syntax.BinaryExpression:
      case Syntax.LogicalExpression:
        node.aaa = [node.operator, node.left.aaa, node.right.aaa];
        break;
      case Syntax.UnaryExpression:
        node.aaa = [node.operator, node.argument.aaa];
        break;
      case Syntax.AssignmentExpression:
        node.aaa = [node.left.aaa, node.right.aaa];
        break;
      case Syntax.ExpressionStatement:
        node.aaa = node.expression.aaa;
        break;
      case Syntax.Program:
        res = { assign: node.body.map(function (e) { return e.aaa; }) };
        break;
      default:
        node.aaa = 'unknown';
      }
    }
  });
  // console.log(JSON.stringify(res));
  return renderAssign(options.index, res);
}

module.exports = r;

},{"./render-assign.js":10,"estraverse":12}],10:[function(require,module,exports){
'use strict';

const render = require('./render.js');
const drawBoxes = require('./draw_boxes.js');
const insertSVGTemplateAssign = require('./insert-svg-template-assign.js');

function renderAssign (index, source) {
  // var tree,
  //     state,
  //     xmax,
  //     // grid = ['g'],
  //     // svgcontent,
  //     width,
  //     height,
  //     i,
  //     ilen;
  //     // j,
  //     // jlen;

  let state = {x: 0, y: 2, xmax: 0};
  const tree = source.assign;
  const ilen = tree.length;
  for (let i = 0; i < ilen; i++) {
    state = render(tree[i], state);
    state.x++;
  }
  const xmax = state.xmax + 3;

  const svg = ['g'];
  for (let i = 0; i < ilen; i++) {
    svg.push(drawBoxes(tree[i], xmax));
  }
  const width  = 32 * (xmax + 1) + 1;
  const height = 8 * (state.y + 1) - 7;

  // const ilen = 4 * (xmax + 1);
  // jlen = state.y + 1;
  // for (i = 0; i <= ilen; i++) {
  //     for (j = 0; j <= jlen; j++) {
  //         grid.push(['rect', {
  //             height: 1,
  //             width: 1,
  //             x: (i * 8 - 0.5),
  //             y: (j * 8 - 0.5),
  //             class: 'grid'
  //         }]);
  //     }
  // }

  return ['svg', {
    id: 'svgcontent_' + index,
    viewBox: '0 0 ' + width + ' ' + height,
    width: width,
    height: height
  },
  insertSVGTemplateAssign(),
  ['g', {transform:'translate(0.5, 0.5)'}, svg]
  ];
}

module.exports = renderAssign;

/* eslint-env browser */

},{"./draw_boxes.js":3,"./insert-svg-template-assign.js":8,"./render.js":11}],11:[function(require,module,exports){
'use strict';

function render(tree, state) {
  // var y, i, ilen;

  state.xmax = Math.max(state.xmax, state.x);

  const y = state.y;
  const ilen = tree.length;

  for (let i = 1; i < ilen; i++) {
    const branch = tree[i];
    if (Array.isArray(branch)) {
      state = render(branch, {
        x: (state.x + 1),
        y: state.y,
        xmax: state.xmax
      });
    } else {
      tree[i] = {
        name: branch,
        x: (state.x + 1),
        y: state.y
      };
      state.y += 2;
    }
  }

  tree[0] = {
    name: tree[0],
    x: state.x,
    y: Math.round((y + (state.y - 2)) / 2)
  };

  state.x--;
  return state;
}

module.exports = render;

},{}],12:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true*/
(function clone(exports) {
    'use strict';

    var Syntax,
        VisitorOption,
        VisitorKeys,
        BREAK,
        SKIP,
        REMOVE;

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ChainExpression: 'ChainExpression',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportExpression: 'ImportExpression',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        AssignmentPattern: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'body'],
        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ChainExpression: ['expression'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'superClass', 'body'],
        ClassExpression: ['id', 'superClass', 'body'],
        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportAllDeclaration: ['source'],
        ExportDefaultDeclaration: ['declaration'],
        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['exported', 'local'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'body'],
        FunctionExpression: ['id', 'params', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportExpression: ['source'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['local'],
        ImportNamespaceSpecifier: ['local'],
        ImportSpecifier: ['imported', 'local'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MetaProperty: ['meta', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        RestElement: [ 'argument' ],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        Super: [],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handler', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};
    REMOVE = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    Reference.prototype.remove = function remove() {
        if (Array.isArray(this.parent)) {
            this.parent.splice(this.key, 1);
            return true;
        } else {
            this.replace(null);
            return false;
        }
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (Array.isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return type of current node
    Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    // API:
    // remove node
    Controller.prototype.remove = function () {
        this.notify(REMOVE);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === 'iteration') {
            this.__fallback = Object.keys;
        } else if (typeof visitor.fallback === 'function') {
            this.__fallback = visitor.fallback;
        }

        this.__keys = VisitorKeys;
        if (visitor.keys) {
            this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
        }
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }
  
    function candidateExistsInLeaveList(leavelist, candidate) {
        for (var i = leavelist.length - 1; i >= 0; --i) {
            if (leavelist[i].node === candidate) {
                return true;
            }
        }
        return false;
    }

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = node.type || element.wrap;
                candidates = this.__keys[nodeType];
                if (!candidates) {
                    if (this.__fallback) {
                        candidates = this.__fallback(node);
                    } else {
                        throw new Error('Unknown node type ' + nodeType + '.');
                    }
                }

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (Array.isArray(candidate)) {
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }

                            if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                              continue;
                            }

                            if (isProperty(nodeType, candidates[current])) {
                                element = new Element(candidate[current2], [key, current2], 'Property', null);
                            } else if (isNode(candidate[current2])) {
                                element = new Element(candidate[current2], [key, current2], null, null);
                            } else {
                                continue;
                            }
                            worklist.push(element);
                        }
                    } else if (isNode(candidate)) {
                        if (candidateExistsInLeaveList(leavelist, candidate)) {
                          continue;
                        }

                        worklist.push(new Element(candidate, key, null, null));
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        function removeElem(element) {
            var i,
                key,
                nextElem,
                parent;

            if (element.ref.remove()) {
                // When the reference is an element of an array.
                key = element.ref.key;
                parent = element.ref.parent;

                // If removed from array, then decrease following items' keys.
                i = worklist.length;
                while (i--) {
                    nextElem = worklist[i];
                    if (nextElem.ref && nextElem.ref.parent === parent) {
                        if  (nextElem.ref.key < key) {
                            break;
                        }
                        --nextElem.ref.key;
                    }
                }
            }
        }

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === REMOVE || target === REMOVE) {
                    removeElem(element);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
                element.node = null;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = this.__fallback(node);
                } else {
                    throw new Error('Unknown node type ' + nodeType + '.');
                }
            }

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (Array.isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function () { return clone({}); };

    return exports;
}(exports));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],13:[function(require,module,exports){
'use strict';

const w3 = {
  svg: 'http://www.w3.org/2000/svg',
  xlink: 'http://www.w3.org/1999/xlink',
  xmlns: 'http://www.w3.org/XML/1998/namespace'
};

module.exports = (w, h) => ['svg', {
  xmlns: w3.svg, 'xmlns:xlink': w3.xlink,
  width: w, height: h,
  viewBox: '0 0 ' + w + ' ' + h
}];

},{}],14:[function(require,module,exports){
'use strict';

module.exports = (x, y, obj) => {
  let objt = {};
  if (x || y) {
    const tt = [x || 0].concat(y ? [y] : []);
    objt = {transform: 'translate(' + tt.join(',') + ')'};
  }
  obj = (typeof obj === 'object') ? obj : {};
  return Object.assign(objt, obj);
};

},{}],15:[function(require,module,exports){
'use strict';

var parse = require('./parse'),
    reparse = require('./reparse');

exports.parse = parse;
exports.reparse = reparse;

},{"./parse":16,"./reparse":17}],16:[function(require,module,exports){
'use strict';

var escapeMap = {
    '&': '&amp;',
    '"': '&quot;',
    '<': '&lt;',
    '>': '&gt;'
};

function xscape (val) {
    if (typeof val !== 'string') {
        return val;
    }
    return val.replace(
        /([&"<>])/g,
        function (_, e) {
            return escapeMap[e];
        }
    );
}

var token = /<o>|<ins>|<s>|<sub>|<sup>|<b>|<i>|<tt>|<\/o>|<\/ins>|<\/s>|<\/sub>|<\/sup>|<\/b>|<\/i>|<\/tt>/;

function update (s, cmd) {
    if (cmd.add) {
        cmd.add.split(';').forEach(function (e) {
            var arr = e.split(' ');
            s[arr[0]][arr[1]] = true;
        });
    }
    if (cmd.del) {
        cmd.del.split(';').forEach(function (e) {
            var arr = e.split(' ');
            delete s[arr[0]][arr[1]];
        });
    }
}

var trans = {
    '<o>'    : { add: 'text-decoration overline' },
    '</o>'   : { del: 'text-decoration overline' },

    '<ins>'  : { add: 'text-decoration underline' },
    '</ins>' : { del: 'text-decoration underline' },

    '<s>'    : { add: 'text-decoration line-through' },
    '</s>'   : { del: 'text-decoration line-through' },

    '<b>'    : { add: 'font-weight bold' },
    '</b>'   : { del: 'font-weight bold' },

    '<i>'    : { add: 'font-style italic' },
    '</i>'   : { del: 'font-style italic' },

    '<sub>'  : { add: 'baseline-shift sub;font-size .7em' },
    '</sub>' : { del: 'baseline-shift sub;font-size .7em' },

    '<sup>'  : { add: 'baseline-shift super;font-size .7em' },
    '</sup>' : { del: 'baseline-shift super;font-size .7em' },

    '<tt>'   : { add: 'font-family monospace' },
    '</tt>'  : { del: 'font-family monospace' }
};

function dump (s) {
    return Object.keys(s).reduce(function (pre, cur) {
        var keys = Object.keys(s[cur]);
        if (keys.length > 0) {
            pre[cur] = keys.join(' ');
        }
        return pre;
    }, {});
}

function parse (str) {
    var state, res, i, m, a;

    if (str === undefined) {
        return [];
    }

    if (typeof str === 'number') {
        return [str + ''];
    }

    if (typeof str !== 'string') {
        return [str];
    }

    res = [];

    state = {
        'text-decoration': {},
        'font-weight': {},
        'font-style': {},
        'baseline-shift': {},
        'font-size': {},
        'font-family': {}
    };

    while (true) {
        i = str.search(token);

        if (i === -1) {
            res.push(['tspan', dump(state), xscape(str)]);
            return res;
        }

        if (i > 0) {
            a = str.slice(0, i);
            res.push(['tspan', dump(state), xscape(a)]);
        }

        m = str.match(token)[0];

        update(state, trans[m]);

        str = str.slice(i + m.length);

        if (str.length === 0) {
            return res;
        }
    }
}

module.exports = parse;
/* eslint no-constant-condition: 0 */

},{}],17:[function(require,module,exports){
'use strict';

var parse = require('./parse');

function deDash (str) {
    var m = str.match(/(\w+)-(\w)(\w+)/);
    if (m === null) {
        return str;
    }
    var newStr = m[1] + m[2].toUpperCase() + m[3];
    return newStr;
}

function reparse (React) {

    var $ = React.createElement;

    function reTspan (e, i) {
        var tag = e[0];
        var attr = e[1];

        var newAttr = Object.keys(attr).reduce(function (res, key) {
            var newKey = deDash(key);
            res[newKey] = attr[key];
            return res;
        }, {});

        var body = e[2];
        newAttr.key = i;
        return $(tag, newAttr, body);
    }

    return function (str) {
        return parse(str).map(reTspan);
    };
}

module.exports = reparse;

},{"./parse":16}]},{},[7])(7)
});
